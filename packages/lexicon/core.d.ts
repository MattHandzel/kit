type UUID = string;

export type Lazy<T> = T | string;
/**
 * An execution plan is a portable definition of a Work Order,
 * or, a unit of work to execute
 * Should it include initial state? I don't really think so
 * // BUT the plan sent from Lightning DOES include the initial state
 */
export type ExecutionPlan = {
  id?: UUID; // this would bet the run (nee attempt)  id
  workflow: Workflow;
  options: WorkflowOptions;
};

/**
 * A workflow is just a series of steps, executed start to finish
 */
export type Workflow = {
  id?: UUID; // unique id used to track this workflow. Could be autogenerated

  // TODO: make required
  name?: string; // user-friendly name. CLI can derive this from file names

  // TODO - rename jobs to steps
  // TODO - support Trigger types in steps
  jobs: Array<Job>;
  //steps: Array<Job>;
};

/**
 * Options which can be set on a workflow as part of an execution plan
 */
export type WorkflowOptions = {
  // Both numbers in minutes maybe
  timeout?: number;
  stepTimeout?: number;
  start?: StepId;

  statePropsToRemove?: string[];
};

export type StepId = string;

/**
 * A thing to be run as part of a workflow
 * (usually a job)
 */
export interface Step {
  id?: StepId; // is this really required? It could be generated
  name?: string; // user-friendly name used in logging

  next?: string | Record<StepId, StepEdge>;
  previous?: StepId;
}

/**
 * Not actually keen on the node/edge semantics here
 */
export type StepEdge =
  | boolean
  | string
  | {
      condition?: string; // Javascript expression (function body, not function)
      label?: string;
      disabled?: boolean;
    };

/**
 * A type of Step which executes code
 */
export interface Job extends Step {
  adaptor?: string;
  expression: string;
  configuration?: object | string;
  state?: Omit<State, 'configuration'> | string;
}

/**
 * A no-op type of Step
 */
export interface Trigger extends Step {}

/**
 * A raw openfn-js script to be executed by the runtime
 *
 * Can be compiled as part of a job
 */
export type Expression = string;

/**
 * An expression which has been compiled, and so includes import and export statements
 */
export type CompiledExpression = Expression;

export declare interface State<S = object, C = object> {
  // Core state props
  configuration?: C;
  data?: S;
  errors?: Record<StepId, ErrorReport>;

  // Added by common
  references?: Array<any>;

  // Typically used by other adaptors
  index?: number;
  response?: any;
  query?: any;

  [other: string]: any;
}

/**
 * An operation function that runs in an Expression
 */
export declare interface Operation<T = Promise<State> | State> {
  (state: State): T;
}

export type ErrorReport = {
  type: string; // The name/type of error, ie Error, TypeError
  message: string; // simple human readable message
  stepId: StepId; // ID of the associated job
  jobId?: StepId; // deprecated
  error: Error; // the original underlying error object

  code?: string; // The error code, if any (found on node errors)
  stack?: string; // not sure this is useful?
  data?: any; // General store for related error information
};

/*


run (workflow, options)


some options relate to the workflow:
- initial state
- start node
- timeout

others are system settings
- linker (paths, whitelist)
- statePropsToRemove
- loggers
- sandbox rules
- callbacks (notify, lazy loaders)

Some of those system things might just be defaults - although maybe it's cleaner for the engine to do that
*/
