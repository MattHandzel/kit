import test from 'ava';
import handleStepStart from '../../src/events/step-start';

import { JobStartPayload } from '@openfn/engine-multi';

import { mockChannel } from '../../src/mock/sockets';
import { createRunState } from '../../src/util';
import { RUN_LOG, STEP_START } from '../../src/events';

import pkg from '../../package.json' assert { type: 'json' };

test('set a step id and active job on state', async (t) => {
  const plan = {
    id: 'run-1',
    workflow: { steps: [{ id: 'job-1' }] },
    options: {},
  };
  const jobId = 'job-1';

  const state = createRunState(plan);

  const channel = mockChannel({
    [STEP_START]: (x) => x,
    [RUN_LOG]: (x) => x,
  });

  await handleStepStart({ channel, state } as any, { jobId } as any);

  t.is(state.activeJob, jobId);
  t.truthy(state.activeStep);
});

test('send a step:start event', async (t) => {
  const plan = {
    id: 'run-1',
    workflow: {
      steps: [
        { id: 'job-1', expression: '.' },
        { id: 'job-2', expression: '.' },
      ],
    },
    options: {},
  };
  const input = 'abc';
  const jobId = 'job-1';

  const state = createRunState(plan, input);
  state.activeJob = jobId;
  state.activeStep = 'b';

  const channel = mockChannel({
    [STEP_START]: (evt) => {
      t.is(evt.job_id, jobId);
      t.is(evt.input_dataclip_id, input);
      t.truthy(evt.step_id);
      return true;
    },
    [RUN_LOG]: () => true,
  });

  await handleStepStart({ channel, state } as any, { jobId } as any);
});

test('step:start event should include versions', async (t) => {
  const plan = {
    id: 'run-1',
    workflow: {
      steps: [{ id: 'job-1', expression: '.' }],
    },
    options: {},
  };
  const input = 'abc';
  const jobId = 'job-1';

  const versions = {
    node: process.version.substring(1),
    engine: '1.0.0',
    compiler: '1.0.0',
    worker: pkg.version,
  };

  // Simulate an event that would be generated by the worker
  const event: JobStartPayload = {
    jobId,
    workflowId: plan.id,
    versions,
  };

  const state = createRunState(plan, input);
  state.activeJob = jobId;
  state.activeStep = 'b';

  const channel = mockChannel({
    [STEP_START]: (evt) => {
      t.deepEqual(evt.versions, {
        ...versions,
        worker: pkg.version,
      });
      return true;
    },
    [RUN_LOG]: () => true,
  });

  await handleStepStart({ channel, state } as any, event);
});

test('also logs the version number', async (t) => {
  let logEvent: any;
  const plan = {
    id: 'run-1',
    workflow: {
      steps: [{ id: 'job-1', expression: '.' }],
    },
    options: {},
  };
  const input = 'abc';
  const jobId = 'job-1';

  const versions = {
    node: process.version.substring(1),
    engine: '1.0.0',
    compiler: '1.0.0',
    worker: pkg.version,
  };

  // Simulate an event that would be generated by the worker
  const event: JobStartPayload = {
    jobId,
    workflowId: plan.id,
    versions,
  };

  const state = createRunState(plan, input);
  state.activeJob = jobId;
  state.activeStep = 'b';

  const channel = mockChannel({
    [STEP_START]: () => true,
    [RUN_LOG]: (evt) => {
      if (evt.source === 'VER') {
        logEvent = evt;
      }
      return true;
    },
  });

  await handleStepStart({ channel, state } as any, event);

  t.truthy(logEvent);
  t.is(logEvent.level, 'info');
  const [message] = logEvent.message;
  t.log(message);
  // This just a light test of the string to make sure it's here
  // It uses src/util/versions, which is tested elsewhere
  t.regex(message, /(node\.js).+(worker).+(engine)/is);
});
